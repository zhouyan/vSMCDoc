<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>vSMC: vsmc::CLManager&lt; ID &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vSMC
   </div>
   <div id="projectbrief">vSMC: Scalable Monte Carlo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevsmc.html">vsmc</a></li><li class="navelem"><a class="el" href="classvsmc_1_1_c_l_manager.html">CLManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvsmc_1_1_c_l_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vsmc::CLManager&lt; ID &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___open_c_l.html">OpenCL</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>OpenCL Manager.  
 <a href="classvsmc_1_1_c_l_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl__manager_8hpp_source.html">vsmc/opencl/cl_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad50206b3da7bd384e419c373cb1aef43"><td class="memItemLeft" align="right" valign="top">typedef ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#ad50206b3da7bd384e419c373cb1aef43">id</a></td></tr>
<tr class="separator:ad50206b3da7bd384e419c373cb1aef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac966064d21e7d2b3b96f5a0b12ce1ee2"><td class="memItemLeft" align="right" valign="top">const ::cl::CommandQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#ac966064d21e7d2b3b96f5a0b12ce1ee2">command_queue</a> () const </td></tr>
<tr class="memdesc:ac966064d21e7d2b3b96f5a0b12ce1ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command queue currently being used.  <a href="#ac966064d21e7d2b3b96f5a0b12ce1ee2">More...</a><br /></td></tr>
<tr class="separator:ac966064d21e7d2b3b96f5a0b12ce1ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106457193fa0d51f3861faeb5acd90a5"><td class="memItemLeft" align="right" valign="top">const ::cl::Context &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a106457193fa0d51f3861faeb5acd90a5">context</a> () const </td></tr>
<tr class="memdesc:a106457193fa0d51f3861faeb5acd90a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context currently being used.  <a href="#a106457193fa0d51f3861faeb5acd90a5">More...</a><br /></td></tr>
<tr class="separator:a106457193fa0d51f3861faeb5acd90a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7b094f21a262849b2800bd05ba57c7"><td class="memTemplParams" colspan="2">template&lt;typename CLType &gt; </td></tr>
<tr class="memitem:a4b7b094f21a262849b2800bd05ba57c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a4b7b094f21a262849b2800bd05ba57c7">copy_buffer</a> (const ::cl::Buffer &amp;src, const ::cl::Buffer &amp;dst, std::size_t num, std::size_t src_offset=0, std::size_t dst_offset=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:a4b7b094f21a262849b2800bd05ba57c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an OpenCL buffer into another of a given type and number of elements.  <a href="#a4b7b094f21a262849b2800bd05ba57c7">More...</a><br /></td></tr>
<tr class="separator:a4b7b094f21a262849b2800bd05ba57c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e758024a8bf9eb956bf25b8132efb7"><td class="memTemplParams" colspan="2">template&lt;typename CLType &gt; </td></tr>
<tr class="memitem:a25e758024a8bf9eb956bf25b8132efb7"><td class="memTemplItemLeft" align="right" valign="top">::cl::Buffer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a25e758024a8bf9eb956bf25b8132efb7">create_buffer</a> (std::size_t num) const </td></tr>
<tr class="memdesc:a25e758024a8bf9eb956bf25b8132efb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OpenCL buffer of a given type and number of elements.  <a href="#a25e758024a8bf9eb956bf25b8132efb7">More...</a><br /></td></tr>
<tr class="separator:a25e758024a8bf9eb956bf25b8132efb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763bbd9278c5d33269b3a6303f29a1fd"><td class="memTemplParams" colspan="2">template&lt;typename CLType , typename InputIter &gt; </td></tr>
<tr class="memitem:a763bbd9278c5d33269b3a6303f29a1fd"><td class="memTemplItemLeft" align="right" valign="top">::cl::Buffer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a763bbd9278c5d33269b3a6303f29a1fd">create_buffer</a> (InputIter first, InputIter last, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:a763bbd9278c5d33269b3a6303f29a1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OpenCL buffer of a given type from a range of elements.  <a href="#a763bbd9278c5d33269b3a6303f29a1fd">More...</a><br /></td></tr>
<tr class="separator:a763bbd9278c5d33269b3a6303f29a1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc59a618c920cb937524682d0c3b0310"><td class="memItemLeft" align="right" valign="top">::cl::Program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#adc59a618c920cb937524682d0c3b0310">create_program</a> (const std::string &amp;source) const </td></tr>
<tr class="memdesc:adc59a618c920cb937524682d0c3b0310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a program given the source within the current context.  <a href="#adc59a618c920cb937524682d0c3b0310">More...</a><br /></td></tr>
<tr class="separator:adc59a618c920cb937524682d0c3b0310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19fc4b132132ef0eab2671ec1b6fc7d"><td class="memItemLeft" align="right" valign="top">const ::cl::Device &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#af19fc4b132132ef0eab2671ec1b6fc7d">device</a> () const </td></tr>
<tr class="memdesc:af19fc4b132132ef0eab2671ec1b6fc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device currently being used.  <a href="#af19fc4b132132ef0eab2671ec1b6fc7d">More...</a><br /></td></tr>
<tr class="separator:af19fc4b132132ef0eab2671ec1b6fc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698c2e78c797ac0a496cdc521d19bd1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; ::cl::Device &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#ae698c2e78c797ac0a496cdc521d19bd1">device_vec</a> () const </td></tr>
<tr class="memdesc:ae698c2e78c797ac0a496cdc521d19bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector of all device that the manager found in the platform.  <a href="#ae698c2e78c797ac0a496cdc521d19bd1">More...</a><br /></td></tr>
<tr class="separator:ae698c2e78c797ac0a496cdc521d19bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351d35ebf711560f775e3f973692392"><td class="memItemLeft" align="right" valign="top">const ::cl::Platform &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#aa351d35ebf711560f775e3f973692392">platform</a> () const </td></tr>
<tr class="memdesc:aa351d35ebf711560f775e3f973692392"><td class="mdescLeft">&#160;</td><td class="mdescRight">The platform currently being used.  <a href="#aa351d35ebf711560f775e3f973692392">More...</a><br /></td></tr>
<tr class="separator:aa351d35ebf711560f775e3f973692392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57f34265d4ab8773479b3b224ef38e"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a5f57f34265d4ab8773479b3b224ef38e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a5f57f34265d4ab8773479b3b224ef38e">print_build_log</a> (const ::cl::Program &amp;program, std::basic_ostream&lt; CharT, <a class="el" href="classvsmc_1_1_traits.html">Traits</a> &gt; &amp;os=std::cout)</td></tr>
<tr class="memdesc:a5f57f34265d4ab8773479b3b224ef38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print build log.  <a href="#a5f57f34265d4ab8773479b3b224ef38e">More...</a><br /></td></tr>
<tr class="separator:a5f57f34265d4ab8773479b3b224ef38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa25dbfe6641f9cfe268df50e2e06234"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:afa25dbfe6641f9cfe268df50e2e06234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvsmc_1_1cxx11_1_1enable__if.html">cxx11::enable_if</a><br class="typebreak" />
&lt; !<a class="el" href="structvsmc_1_1cxx11_1_1is__same.html">cxx11::is_same</a>&lt; Func, <br class="typebreak" />
std::size_t &gt;::value <br class="typebreak" />
&amp;&amp;!<a class="el" href="structvsmc_1_1cxx11_1_1is__convertible.html">cxx11::is_convertible</a>&lt; Func, <br class="typebreak" />
std::size_t &gt;::value, <br class="typebreak" />
std::size_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#afa25dbfe6641f9cfe268df50e2e06234">profile_kernel</a> (::cl::Kernel &amp;kern, std::size_t N, const Func &amp;func, std::size_t lmin=0, std::size_t repeat=10)</td></tr>
<tr class="memdesc:afa25dbfe6641f9cfe268df50e2e06234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the kernel with all local size that are multiples of the preferred factor, return the local size that is the fatest.  <a href="#afa25dbfe6641f9cfe268df50e2e06234">More...</a><br /></td></tr>
<tr class="separator:afa25dbfe6641f9cfe268df50e2e06234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0364de7035c876ad0dee6a4b4f724c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#aba0364de7035c876ad0dee6a4b4f724c">profile_kernel</a> (::cl::Kernel &amp;kern, std::size_t N, std::size_t lmin=0, std::size_t repeat=3)</td></tr>
<tr class="separator:aba0364de7035c876ad0dee6a4b4f724c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48588b2fdcaf621b0c1f8c19b048a615"><td class="memTemplParams" colspan="2">template&lt;typename CLType , typename OutputIter &gt; </td></tr>
<tr class="memitem:a48588b2fdcaf621b0c1f8c19b048a615"><td class="memTemplItemLeft" align="right" valign="top">OutputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a48588b2fdcaf621b0c1f8c19b048a615">read_buffer</a> (const ::cl::Buffer &amp;buf, std::size_t num, OutputIter first, std::size_t offset=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:a48588b2fdcaf621b0c1f8c19b048a615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an OpenCL buffer of a given type and number of elements into an iterator.  <a href="#a48588b2fdcaf621b0c1f8c19b048a615">More...</a><br /></td></tr>
<tr class="separator:a48588b2fdcaf621b0c1f8c19b048a615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13863f918aec591f2c6fdaf0a00fe3e"><td class="memTemplParams" colspan="2">template&lt;typename CLType &gt; </td></tr>
<tr class="memitem:ae13863f918aec591f2c6fdaf0a00fe3e"><td class="memTemplItemLeft" align="right" valign="top">CLType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#ae13863f918aec591f2c6fdaf0a00fe3e">read_buffer</a> (const ::cl::Buffer &amp;buf, std::size_t num, CLType *first, std::size_t offset=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:ae13863f918aec591f2c6fdaf0a00fe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an OpenCL buffer of a given type and number of elements into a pointer.  <a href="#ae13863f918aec591f2c6fdaf0a00fe3e">More...</a><br /></td></tr>
<tr class="separator:ae13863f918aec591f2c6fdaf0a00fe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd328936232d81fe7884e5cdeabd810e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#abd328936232d81fe7884e5cdeabd810e">run_kernel</a> (const ::cl::Kernel &amp;kern, std::size_t N, std::size_t local_size=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:abd328936232d81fe7884e5cdeabd810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a given kernel with one dimensional global size and local size on the current command queue.  <a href="#abd328936232d81fe7884e5cdeabd810e">More...</a><br /></td></tr>
<tr class="separator:abd328936232d81fe7884e5cdeabd810e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eda05068df8772d61fee36d89e02ad4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a> () const </td></tr>
<tr class="memdesc:a5eda05068df8772d61fee36d89e02ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the platform, context, device and command queue has been setup correctly.  <a href="#a5eda05068df8772d61fee36d89e02ad4">More...</a><br /></td></tr>
<tr class="separator:a5eda05068df8772d61fee36d89e02ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05520fe7c52657d03e8ae85b98e3cb51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a05520fe7c52657d03e8ae85b98e3cb51">setup</a> (cl_device_type dev)</td></tr>
<tr class="memdesc:a05520fe7c52657d03e8ae85b98e3cb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to setup the platform, context, device and command queue using the given device type.  <a href="#a05520fe7c52657d03e8ae85b98e3cb51">More...</a><br /></td></tr>
<tr class="separator:a05520fe7c52657d03e8ae85b98e3cb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3e6bb34c3ee0e4535baaaddf22f46b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a8a3e6bb34c3ee0e4535baaaddf22f46b">setup</a> (const ::cl::Platform &amp;plat, const ::cl::Context &amp;ctx, const ::cl::Device &amp;dev, const ::cl::CommandQueue &amp;cmd)</td></tr>
<tr class="memdesc:a8a3e6bb34c3ee0e4535baaaddf22f46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the platform, context, device and command queue manually.  <a href="#a8a3e6bb34c3ee0e4535baaaddf22f46b">More...</a><br /></td></tr>
<tr class="separator:a8a3e6bb34c3ee0e4535baaaddf22f46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0a7b326f7be9a310fb8e114fc046d"><td class="memTemplParams" colspan="2">template&lt;typename CLType , typename InputIter &gt; </td></tr>
<tr class="memitem:a7ca0a7b326f7be9a310fb8e114fc046d"><td class="memTemplItemLeft" align="right" valign="top">InputIter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a7ca0a7b326f7be9a310fb8e114fc046d">write_buffer</a> (const ::cl::Buffer &amp;buf, std::size_t num, InputIter first, std::size_t offset=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:a7ca0a7b326f7be9a310fb8e114fc046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an OpenCL buffer of a given type and number of elements from an iterator.  <a href="#a7ca0a7b326f7be9a310fb8e114fc046d">More...</a><br /></td></tr>
<tr class="separator:a7ca0a7b326f7be9a310fb8e114fc046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d0a23f6780ee92b7e729fb4e7a174d"><td class="memTemplParams" colspan="2">template&lt;typename CLType &gt; </td></tr>
<tr class="memitem:a41d0a23f6780ee92b7e729fb4e7a174d"><td class="memTemplItemLeft" align="right" valign="top">const CLType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#a41d0a23f6780ee92b7e729fb4e7a174d">write_buffer</a> (const ::cl::Buffer &amp;buf, std::size_t num, const CLType *first, std::size_t offset=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:a41d0a23f6780ee92b7e729fb4e7a174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an OpenCL buffer of a given type and number of elements from a pointer.  <a href="#a41d0a23f6780ee92b7e729fb4e7a174d">More...</a><br /></td></tr>
<tr class="separator:a41d0a23f6780ee92b7e729fb4e7a174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e7dc8a2aba55f69eeafff73605c18a"><td class="memTemplParams" colspan="2">template&lt;typename CLType &gt; </td></tr>
<tr class="memitem:ab2e7dc8a2aba55f69eeafff73605c18a"><td class="memTemplItemLeft" align="right" valign="top">CLType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#ab2e7dc8a2aba55f69eeafff73605c18a">write_buffer</a> (const ::cl::Buffer &amp;buf, std::size_t num, CLType *first, std::size_t offset=0, const std::vector&lt; ::cl::Event &gt; *events=nullptr,::cl::Event *event=nullptr) const </td></tr>
<tr class="memdesc:ab2e7dc8a2aba55f69eeafff73605c18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an OpenCL buffer of a given type and number of elements from a pointer.  <a href="#ab2e7dc8a2aba55f69eeafff73605c18a">More...</a><br /></td></tr>
<tr class="separator:ab2e7dc8a2aba55f69eeafff73605c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aad6358182bda186ffa3afaac9698d5c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvsmc_1_1_c_l_manager.html">CLManager</a>&lt; ID &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_l_manager.html#aad6358182bda186ffa3afaac9698d5c4">instance</a> ()</td></tr>
<tr class="memdesc:aad6358182bda186ffa3afaac9698d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of the manager singleton.  <a href="#aad6358182bda186ffa3afaac9698d5c4">More...</a><br /></td></tr>
<tr class="separator:aad6358182bda186ffa3afaac9698d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ID = CLDefault&gt;<br />
class vsmc::CLManager&lt; ID &gt;</h3>

<p>OpenCL Manager. </p>
<p>Each instance of <a class="el" href="classvsmc_1_1_c_l_manager.html" title="OpenCL Manager. ">CLManager</a> is an singleton. Different <code>ID</code> template parameter create distinct singletons. Each singleton manages a specific OpenCL device. However, it is possible for different singletons to manage the same device.</p>
<p>The <code>ID</code> template parameter, apart from ensuring that different IDs create distinct singletons, it can also provide additional information about which device <a class="el" href="classvsmc_1_1_c_l_manager.html" title="OpenCL Manager. ">CLManager</a> shall choose by default through the singleton <a class="el" href="classvsmc_1_1_c_l_setup.html" title="Configure the default behavior of CLManager. ">CLSetup</a> with the same <code>ID</code> template argument.</p>
<p>It is important to configure the platform and device to be used through <a class="el" href="classvsmc_1_1_c_l_setup.html" title="Configure the default behavior of CLManager. ">CLSetup</a> before calling <a class="el" href="classvsmc_1_1_c_l_manager.html#aad6358182bda186ffa3afaac9698d5c4" title="Get an instance of the manager singleton. ">CLManager::instance</a> for the first time. If nothing is done by the user, the default behavior is to use <code>CL_DEVICE_TYPE_DEFAULT</code> type device, and set the platform to be the first one that contain such as device, and the device to the first one that is of such a type. The user can change the platform name, device vendor name, device name, and device type through <a class="el" href="classvsmc_1_1_c_l_setup.html" title="Configure the default behavior of CLManager. ">CLSetup</a>. In case of names, only partial match is requried. For example, </p><div class="fragment"><div class="line">CLSetup&lt;CLDefault&gt; &amp;<a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a> = <a class="code" href="classvsmc_1_1_c_l_setup.html#a97919cd99fa74f70c026088dedf9c20b">CLSetup&lt;CLDefault&gt;::instance</a>();</div>
<div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.platform(<span class="stringliteral">&quot;Apple&quot;</span>);</div>
<div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_vendor(<span class="stringliteral">&quot;Intel&quot;</span>);</div>
<div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_type(<span class="stringliteral">&quot;GPU);</span></div>
<div class="line"><span class="stringliteral">setup.device_name(&quot;</span>Iris<span class="stringliteral">&quot;);</span></div>
<div class="line"><span class="stringliteral">CLManager&lt;CLDefault&gt; &amp;manager = CLManager&lt;CLDefault&gt;::instance();</span></div>
</div><!-- fragment --><p> If compiled on a recent MacBook Pro (late 2013 model), then the Iris Pro GPU from Intel will be used. Note that in this case, actually specify </p><div class="fragment"><div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_type(<span class="stringliteral">&quot;GPU&quot;</span>);</div>
<div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_name(<span class="stringliteral">&quot;Iris&quot;</span>)</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_type(<span class="stringliteral">&quot;GPU&quot;</span>);</div>
<div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_vedor(<span class="stringliteral">&quot;Intel&quot;</span>)</div>
</div><!-- fragment --><p> is enough. However, if one specify </p><div class="fragment"><div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_type(<span class="stringliteral">&quot;CPU&quot;</span>);</div>
<div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_vedor(<span class="stringliteral">&quot;NVIDIA&quot;</span>)</div>
</div><!-- fragment --><p> Then the setup will fail, since there is no device with the specified combinations. Also note that, specification such as </p><div class="fragment"><div class="line"><a class="code" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4">setup</a>.device_vendor(<span class="stringliteral">&quot;NVIDIA&quot;</span>)</div>
</div><!-- fragment --><p> may not be enough to lead to successful setup. The default device type <code>CL_DEVICE_TYPE_DEFAULT</code> may not be GPU. To be safe, if one need to use <a class="el" href="classvsmc_1_1_c_l_setup.html" title="Configure the default behavior of CLManager. ">CLSetup</a>, at least specify the device type. It can be set through values of type <code>cl_device_type</code> or a string with values "GPU", "CPU", "Accelerator". Other string values are silently ignored and the default is used.</p>
<p>Before using a <a class="el" href="classvsmc_1_1_c_l_manager.html" title="OpenCL Manager. ">CLManager</a>, it is important to check that <a class="el" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4" title="Whether the platform, context, device and command queue has been setup correctly. ...">CLManager::setup</a> returns <code>true</code>. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00123">123</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad50206b3da7bd384e419c373cb1aef43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ID <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::<a class="el" href="classvsmc_1_1_c_l_manager.html#ad50206b3da7bd384e419c373cb1aef43">id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00127">127</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac966064d21e7d2b3b96f5a0b12ce1ee2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::cl::CommandQueue&amp; <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::command_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The command queue currently being used. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00150">150</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a106457193fa0d51f3861faeb5acd90a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::cl::Context&amp; <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The context currently being used. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00141">141</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b7b094f21a262849b2800bd05ba57c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::copy_buffer </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>src_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dst_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an OpenCL buffer into another of a given type and number of elements. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00340">340</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25e758024a8bf9eb956bf25b8132efb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::cl::Buffer <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::create_buffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an OpenCL buffer of a given type and number of elements. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00212">212</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a763bbd9278c5d33269b3a6303f29a1fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType , typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::cl::Buffer <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::create_buffer </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an OpenCL buffer of a given type from a range of elements. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00224">224</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc59a618c920cb937524682d0c3b0310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::cl::Program <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::create_program </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a program given the source within the current context. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00355">355</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af19fc4b132132ef0eab2671ec1b6fc7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::cl::Device&amp; <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The device currently being used. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00144">144</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae698c2e78c797ac0a496cdc521d19bd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; ::cl::Device&gt;&amp; <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::device_vec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vector of all device that the manager found in the platform. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00147">147</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad6358182bda186ffa3afaac9698d5c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvsmc_1_1_c_l_manager.html">CLManager</a>&lt;ID&gt;&amp; <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an instance of the manager singleton. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00130">130</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa351d35ebf711560f775e3f973692392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ::cl::Platform&amp; <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::platform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The platform currently being used. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00138">138</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f57f34265d4ab8773479b3b224ef38e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::print_build_log </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_ostream&lt; CharT, <a class="el" href="classvsmc_1_1_traits.html">Traits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print build log. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00187">187</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa25dbfe6641f9cfe268df50e2e06234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvsmc_1_1cxx11_1_1enable__if.html">cxx11::enable_if</a>&lt; !<a class="el" href="structvsmc_1_1cxx11_1_1is__same.html">cxx11::is_same</a>&lt;Func, std::size_t&gt;::value &amp;&amp; !<a class="el" href="structvsmc_1_1cxx11_1_1is__convertible.html">cxx11::is_convertible</a>&lt;Func, std::size_t&gt;::value, std::size_t&gt;::type <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::profile_kernel </td>
          <td>(</td>
          <td class="paramtype">::cl::Kernel &amp;&#160;</td>
          <td class="paramname"><em>kern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>lmin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>repeat</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the kernel with all local size that are multiples of the preferred factor, return the local size that is the fatest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kern</td><td>The kernel to be profiled </td></tr>
    <tr><td class="paramname">N</td><td>The global size </td></tr>
    <tr><td class="paramname">func</td><td>A functor that has the following signature, <div class="fragment"><div class="line"><span class="keywordtype">void</span> func (::cl::Kernel &amp;kern)</div>
</div><!-- fragment --> It will be applied to <code>kern</code> before it is run each time </td></tr>
    <tr><td class="paramname">lmin</td><td>The minimum local size to be considered. This function will consider all local sizes that are a multiple of this value. If <code>lmin = 0</code> (the default), then the preferred multiplier queried from the device is used. If its value is bigger than the allowed maximum local size, then it is treated as if it is set to zero. </td></tr>
    <tr><td class="paramname">repeat</td><td>The number of repeatition of runs. The profiling is done by run the kernel once to heat it up, and then repeat runs for this given value. The time of the later is measured and compared for each considered local size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function relies on StopWatch to work correctly. </dd></dl>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00409">409</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba0364de7035c876ad0dee6a4b4f724c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::profile_kernel </td>
          <td>(</td>
          <td class="paramtype">::cl::Kernel &amp;&#160;</td>
          <td class="paramname"><em>kern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>lmin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>repeat</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00460">460</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48588b2fdcaf621b0c1f8c19b048a615"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType , typename OutputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIter <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::read_buffer </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an OpenCL buffer of a given type and number of elements into an iterator. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00247">247</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae13863f918aec591f2c6fdaf0a00fe3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CLType* <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::read_buffer </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLType *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an OpenCL buffer of a given type and number of elements into a pointer. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00268">268</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd328936232d81fe7884e5cdeabd810e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::run_kernel </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Kernel &amp;&#160;</td>
          <td class="paramname"><em>kern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>local_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run a given kernel with one dimensional global size and local size on the current command queue. </p>
<p>OpenCL requires that <code>global_size</code> is a multiple of <code>local_size</code>. This function will round <code>N</code> if it is not already a multiple of <code>local_size</code>. In the kernel it is important to check that <code>get_global_id(0)</code> is not out of range.</p>
<p>For example, say we have kernel that should be applied to <code>N</code> elements. But the most efficient local size <code>K</code> does not divide <code>N</code>. Instead of calculate the correct global size yourself, you can simple call <code>run_kernel(kern, N, K)</code>. But within the kernel, you need to check <code>get_global_id(0) &lt; N</code> </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00372">372</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5eda05068df8772d61fee36d89e02ad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the platform, context, device and command queue has been setup correctly. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00154">154</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05520fe7c52657d03e8ae85b98e3cb51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::setup </td>
          <td>(</td>
          <td class="paramtype">cl_device_type&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to setup the platform, context, device and command queue using the given device type. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00158">158</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a3e6bb34c3ee0e4535baaaddf22f46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::setup </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Platform &amp;&#160;</td>
          <td class="paramname"><em>plat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::cl::Context &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::cl::Device &amp;&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::cl::CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the platform, context, device and command queue manually. </p>
<p>After this member function call <a class="el" href="classvsmc_1_1_c_l_manager.html#a5eda05068df8772d61fee36d89e02ad4" title="Whether the platform, context, device and command queue has been setup correctly. ...">setup()</a> will return <code>true</code> in future calls </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00171">171</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ca0a7b326f7be9a310fb8e114fc046d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType , typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InputIter <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::write_buffer </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an OpenCL buffer of a given type and number of elements from an iterator. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00285">285</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41d0a23f6780ee92b7e729fb4e7a174d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CLType* <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::write_buffer </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLType *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an OpenCL buffer of a given type and number of elements from a pointer. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00305">305</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2e7dc8a2aba55f69eeafff73605c18a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ID = CLDefault&gt; </div>
<div class="memtemplate">
template&lt;typename CLType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CLType* <a class="el" href="classvsmc_1_1_c_l_manager.html">vsmc::CLManager</a>&lt; ID &gt;::write_buffer </td>
          <td>(</td>
          <td class="paramtype">const ::cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLType *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ::cl::Event &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cl::Event *&#160;</td>
          <td class="paramname"><em>event</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an OpenCL buffer of a given type and number of elements from a pointer. </p>

<p>Definition at line <a class="el" href="cl__manager_8hpp_source.html#l00323">323</a> of file <a class="el" href="cl__manager_8hpp_source.html">cl_manager.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
