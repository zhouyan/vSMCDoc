<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>vSMC: CString</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vSMC
   </div>
   <div id="projectbrief">vSMC: Scalable Monte Carlo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CString<div class="ingroups"><a class="el" href="group___utility.html">Utility</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Optimized <code>&lt;cstring&gt;</code> functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvsmc_1_1_c_string_non_temporal_threshold.html">vsmc::CStringNonTemporalThreshold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold of buffer size above which <code>memcpy</code> use non-temporal instructions.  <a href="classvsmc_1_1_c_string_non_temporal_threshold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3f314255383e081509b9c4a2284e38e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gaf3f314255383e081509b9c4a2284e38e">vsmc::memcpy</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:gaf3f314255383e081509b9c4a2284e38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized <code>memcpy</code> with non-temporal store for large buffers.  <a href="#gaf3f314255383e081509b9c4a2284e38e">More...</a><br /></td></tr>
<tr class="separator:gaf3f314255383e081509b9c4a2284e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6837bec73a92f463eb505150e1bf40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gaca6837bec73a92f463eb505150e1bf40">vsmc::memcpy_avx</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:gaca6837bec73a92f463eb505150e1bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX optimized <code>memcpy</code> with non-temporal store for large buffers.  <a href="#gaca6837bec73a92f463eb505150e1bf40">More...</a><br /></td></tr>
<tr class="separator:gaca6837bec73a92f463eb505150e1bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade013046ccf6cec1ad40551498c7359"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gaade013046ccf6cec1ad40551498c7359">vsmc::memcpy_avx_nt</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:gaade013046ccf6cec1ad40551498c7359"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX optimized <code>memcpy</code> with non-temporal store regardless of size.  <a href="#gaade013046ccf6cec1ad40551498c7359">More...</a><br /></td></tr>
<tr class="separator:gaade013046ccf6cec1ad40551498c7359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b9bc9e229b3ad9ff0b96692d39003d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gad3b9bc9e229b3ad9ff0b96692d39003d">vsmc::memcpy_nt</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:gad3b9bc9e229b3ad9ff0b96692d39003d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized <code>memcpy</code> with non-temporal store regardless of size.  <a href="#gad3b9bc9e229b3ad9ff0b96692d39003d">More...</a><br /></td></tr>
<tr class="separator:gad3b9bc9e229b3ad9ff0b96692d39003d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bda107eed87c4cf1a6f80c8ad01a3dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#ga9bda107eed87c4cf1a6f80c8ad01a3dd">vsmc::memcpy_sse2</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:ga9bda107eed87c4cf1a6f80c8ad01a3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE2 optimized <code>memcpy</code> with non-temporal store for large buffers.  <a href="#ga9bda107eed87c4cf1a6f80c8ad01a3dd">More...</a><br /></td></tr>
<tr class="separator:ga9bda107eed87c4cf1a6f80c8ad01a3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad97af63cc32ade4e973718a69378e2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gabad97af63cc32ade4e973718a69378e2">vsmc::memcpy_sse2_nt</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:gabad97af63cc32ade4e973718a69378e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE2 optimized <code>memcpy</code> with non-temporal store regardless of size.  <a href="#gabad97af63cc32ade4e973718a69378e2">More...</a><br /></td></tr>
<tr class="separator:gabad97af63cc32ade4e973718a69378e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689bf74910fc1bdd351616df8c6462e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#ga689bf74910fc1bdd351616df8c6462e3">vsmc::memcpy_std</a> (void *dst, const void *src, std::size_t n)</td></tr>
<tr class="memdesc:ga689bf74910fc1bdd351616df8c6462e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct call to <code>std::memcpy</code>  <a href="#ga689bf74910fc1bdd351616df8c6462e3">More...</a><br /></td></tr>
<tr class="separator:ga689bf74910fc1bdd351616df8c6462e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab326d5ff6753241bc5e9a31e49db4f68"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gab326d5ff6753241bc5e9a31e49db4f68">vsmc::memset</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:gab326d5ff6753241bc5e9a31e49db4f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized <code>memset</code> with non-temporal store for large buffers.  <a href="#gab326d5ff6753241bc5e9a31e49db4f68">More...</a><br /></td></tr>
<tr class="separator:gab326d5ff6753241bc5e9a31e49db4f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8f4fb6a0a50ce91e2c881361771e9c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#ga1f8f4fb6a0a50ce91e2c881361771e9c">vsmc::memset_avx</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:ga1f8f4fb6a0a50ce91e2c881361771e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX optimized <code>memset</code> with non-temporal store for large buffers.  <a href="#ga1f8f4fb6a0a50ce91e2c881361771e9c">More...</a><br /></td></tr>
<tr class="separator:ga1f8f4fb6a0a50ce91e2c881361771e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb03b34a9f6f61a5bea9e31e3cdfd61"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gafdb03b34a9f6f61a5bea9e31e3cdfd61">vsmc::memset_avx_nt</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:gafdb03b34a9f6f61a5bea9e31e3cdfd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVX optimized <code>memset</code> with non-temporal store regardless of size.  <a href="#gafdb03b34a9f6f61a5bea9e31e3cdfd61">More...</a><br /></td></tr>
<tr class="separator:gafdb03b34a9f6f61a5bea9e31e3cdfd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce38f0b635b275e91224290c6a67988"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#ga1ce38f0b635b275e91224290c6a67988">vsmc::memset_nt</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:ga1ce38f0b635b275e91224290c6a67988"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD optimized <code>memset</code> with non-temporal store regardless of size.  <a href="#ga1ce38f0b635b275e91224290c6a67988">More...</a><br /></td></tr>
<tr class="separator:ga1ce38f0b635b275e91224290c6a67988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7929d5c570f0216bc235c48ec68bbc90"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#ga7929d5c570f0216bc235c48ec68bbc90">vsmc::memset_sse2</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:ga7929d5c570f0216bc235c48ec68bbc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE2 optimized <code>memset</code> with non-temporal store for large buffers.  <a href="#ga7929d5c570f0216bc235c48ec68bbc90">More...</a><br /></td></tr>
<tr class="separator:ga7929d5c570f0216bc235c48ec68bbc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b875cae0edb02d83456a2fe8fd5a02"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#gab0b875cae0edb02d83456a2fe8fd5a02">vsmc::memset_sse2_nt</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:gab0b875cae0edb02d83456a2fe8fd5a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE2 optimized <code>memset</code> with non-temporal store regardless of size.  <a href="#gab0b875cae0edb02d83456a2fe8fd5a02">More...</a><br /></td></tr>
<tr class="separator:gab0b875cae0edb02d83456a2fe8fd5a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4c79fb4b94e5c92f67da89b3e151c0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_string.html#ga8c4c79fb4b94e5c92f67da89b3e151c0">vsmc::memset_std</a> (void *dst, <a class="el" href="classint.html">int</a> ch, std::size_t n)</td></tr>
<tr class="memdesc:ga8c4c79fb4b94e5c92f67da89b3e151c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct call to <code>std::memset</code>  <a href="#ga8c4c79fb4b94e5c92f67da89b3e151c0">More...</a><br /></td></tr>
<tr class="separator:ga8c4c79fb4b94e5c92f67da89b3e151c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Optimized <code>&lt;cstring&gt;</code> functions. </p>
<p>This module implement the <code>memcpy</code>, etc., functions in the <code>vsmc</code> namespace. The implementaions are optimzied with SIMD instructions. Three groups of functions are provided.</p>
<ul>
<li><code>memcpy_std</code> etc., they simply call <code>std::memcpy</code> etc.</li>
<li><code>memcpy_sse2</code> etc., they are avialable if at least SSE2 is supported and are optimized with SSE2 instructions</li>
<li><code>memcpy_avx</code> etc., they are avialable if at least AVX is supported and are optimized with AVX instructions</li>
</ul>
<p>There are also generic <code><a class="el" href="group___c_string.html#gaf3f314255383e081509b9c4a2284e38e" title="SIMD optimized memcpy with non-temporal store for large buffers. ">vsmc::memcpy</a></code> etc. They dispatch the call based on the following rules.</p>
<ul>
<li>If AVX is available, then call <code>memcpy_avx</code> etc.</li>
<li>Else if SSE2 is available, then call <code>memcpy_sse2</code> etc.</li>
<li>Else call <code>memcpy_std</code>.</li>
</ul>
<p>This dispatch can be done at compile time if the configuration macro <code>VSMC_CSTRING_RUNTIME_DISPATCH</code> is zero. If the macro is non-zero, then it will be done at runtime using <code>CPUID</code> information.</p>
<p>Before using any of these vSMC provided functions. A few factors shall be considered.</p>
<ul>
<li>For large buffers, vSMC functions use non-temporal store instructions. In this case, the performance is likely to be better than the system library or compiler builtins. On Haswell and Nehalem, about 30% performance gain were observed, though 70% were observed in some situations. A more important benefits is that cache pollution may be avoided in this case. The threshold is set to be half the size of the LLC (last level cache). Note that, only up to level 3 cache is considered. Some newer Intel CPUs have level 4 cache, which is shared with the integrated GPU. This threshold can be changed at compile time by define <code>VSMC_CSTRING_NON_TEMPORAL_THRESHOLD</code> or at runtime via CStringNonTemporalThreshold singleton.</li>
<li>For moderate size buffers (from 1KB upto the non-temporal threshold), the performance is most likely to be only comparable to the system. At worst, 20% perforamnce degrade was observed, though in most cases, it is almost as fast as or slightly faster than system library. To change the threshold, <div class="fragment"><div class="line"><a class="code" href="classvsmc_1_1_c_string_non_temporal_threshold.html#aa1a49596c2882c9e2e865b6f1819ff1c">vsmc::CStringNonTemporalThreshold::instance</a>().<a class="code" href="classvsmc_1_1_c_string_non_temporal_threshold.html#aff4c633507427f3cd8de5aa530ed4547">set</a>(new_threshold);</div>
</div><!-- fragment --> To change the maximum level of cache to be considered and reset the threshold accordingly. <div class="fragment"><div class="line"><a class="code" href="classvsmc_1_1_c_string_non_temporal_threshold.html#aa1a49596c2882c9e2e865b6f1819ff1c">vsmc::CStringNonTemporalThreshold::instance</a>().<a class="code" href="classvsmc_1_1_c_string_non_temporal_threshold.html#af874d52ccd33c87016d5a78f75d53b72">max_level</a>(new_level);</div>
</div><!-- fragment --></li>
<li>The performance is only tested on limited models of CPUs. As a single person I don't have much resources. In particle, AMD CPUs were not tested at all.</li>
</ul>
<p>In any case, most systems's standard C library is likely to be optimized enough to suffice most usage situations. And even when there is a noticeable perforamnce difference, unless all the program do is copy and moving memories, the difference is not likely to be big enough to make a difference. And taking caching into consideration, those difference seem in memory dedicated benchmarks might well not exist at all in real programs.</p>
<p>In summary, do some benchmark of real programs before deciding if using these functions are beneficial. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf3f314255383e081509b9c4a2284e38e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized <code>memcpy</code> with non-temporal store for large buffers. </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00923">923</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaca6837bec73a92f463eb505150e1bf40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy_avx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AVX optimized <code>memcpy</code> with non-temporal store for large buffers. </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00820">820</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaade013046ccf6cec1ad40551498c7359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy_avx_nt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AVX optimized <code>memcpy</code> with non-temporal store regardless of size. </p>
<dl class="section note"><dt>Note</dt><dd>The destination and source pointers must be aligned to 32 bytes </dd></dl>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00834">834</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad3b9bc9e229b3ad9ff0b96692d39003d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy_nt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized <code>memcpy</code> with non-temporal store regardless of size. </p>
<dl class="section note"><dt>Note</dt><dd>The destination and source pointers must be aligned to 32 bytes or 16 bytes without AVX support </dd></dl>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00964">964</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9bda107eed87c4cf1a6f80c8ad01a3dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy_sse2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SSE2 optimized <code>memcpy</code> with non-temporal store for large buffers. </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00792">792</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabad97af63cc32ade4e973718a69378e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy_sse2_nt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SSE2 optimized <code>memcpy</code> with non-temporal store regardless of size. </p>
<dl class="section note"><dt>Note</dt><dd>The destination and source pointers must be aligned to 16 bytes </dd></dl>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00806">806</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga689bf74910fc1bdd351616df8c6462e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memcpy_std </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct call to <code>std::memcpy</code> </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00780">780</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab326d5ff6753241bc5e9a31e49db4f68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized <code>memset</code> with non-temporal store for large buffers. </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00906">906</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f8f4fb6a0a50ce91e2c881361771e9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset_avx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AVX optimized <code>memset</code> with non-temporal store for large buffers. </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00815">815</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafdb03b34a9f6f61a5bea9e31e3cdfd61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset_avx_nt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AVX optimized <code>memset</code> with non-temporal store regardless of size. </p>
<dl class="section note"><dt>Note</dt><dd>The destination pointer must be aligned to 32 bytes </dd></dl>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00827">827</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ce38f0b635b275e91224290c6a67988"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset_nt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SIMD optimized <code>memset</code> with non-temporal store regardless of size. </p>
<dl class="section note"><dt>Note</dt><dd>The destination pointer must be aligned to 32 bytes or 16 bytes without AVX support </dd></dl>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00944">944</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7929d5c570f0216bc235c48ec68bbc90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset_sse2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SSE2 optimized <code>memset</code> with non-temporal store for large buffers. </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00787">787</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab0b875cae0edb02d83456a2fe8fd5a02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset_sse2_nt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SSE2 optimized <code>memset</code> with non-temporal store regardless of size. </p>
<dl class="section note"><dt>Note</dt><dd>The destination pointer must be aligned to 16 bytes </dd></dl>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00799">799</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c4c79fb4b94e5c92f67da89b3e151c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vsmc::memset_std </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct call to <code>std::memset</code> </p>

<p>Definition at line <a class="el" href="cstring_8hpp_source.html#l00775">775</a> of file <a class="el" href="cstring_8hpp_source.html">cstring.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
