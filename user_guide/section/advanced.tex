\section{Advanced usage}
\label{sec:Advanced usage}

\subsection{Cloning objects}
\label{sub:Cloning objects}

The \cppinline{Sampler<T>} and \cppinline{Particle<T>} objects have copy
constructors and assignment operators that behaves exactly the way as \cpp
programmers would expect. However, this is behavior is not always desired. For
example, in \textcite{stpf} a stable particle filter in high-dimensions was
developed. Without going into the details, the algorithm consists of a particle
system where each particle is itself a particle filter. And thus when
resampling the global system, the \cppinline{Sampler<T>} object will be copied,
together with all of its sub-objects. This include the \rng system within
\cppinline{Particle<T>} object. Even if the user does not use this \rng system
for random number generating within user defined operations, one of these \rng
will be used for resampling by the \cppinline{Particle<T>} object. Direct
copying these \cppinline{Sampler<T>} objects will lead to multiple filters
start to generating exactly the same random numbers in the next iteration. This
is an undesired side effects. In this situation, one can clone the sampler with
the following method,
\begin{cppcode}
  auto new_sampler = sampler.clone(new_rng);
\end{cppcode}
where \cppinline{new_rng} is a boolean value. If it is \cppinline{true}, then
an exact copy of \cppinline{sampler} will be returned, except it will have the
\rng system re-seeded. If it is \cppinline{false}, then the above call behaves
exactly the same as
\begin{cppcode}
  auto new_sampler = sampler;
\end{cppcode}
Alternatively, the contents of an \cppinline{Sampler<T>} object can be cloned
from another one by the following method,
\begin{cppcode}
  sampler.clone(other_sampler, retain_rng);
\end{cppcode}
where \cppinline{retain_rng} is a boolean value. If it is \cppinline{true},
then the \rng system of \cppinline{other_sampler} is not copied and its own
\rng system is retained. If it is \cppinline{false}, then the above call
behaves exactly the same as
\begin{cppcode}
  sampler = other_sampler;
\end{cppcode}
The above method also supports move semantics. Similar \cppinline{clone}
methods exist for the \cppinline{Particle<T>} class.

\subsection{Customizing member types}
\label{sub:Customizing member types}

The \cppinline{Particle<T>} class has a few member types that can be replaced
by the user. If the class \cppinline{T} has the corresponding types, then the
member type of \cppinline{Particle<T>} will be replaced. For example, given the
following declarations inside class \cppinline{T},
\begin{cppcode}
  class T
  {
    public:
    using size_type = int;
    using weight_type = /* User defined type */;
    using rng_set_type = RNGSetTBB<AES256_4x32>;
  };
\end{cppcode}
The corresponding \cppinline{Particle<T>::size_type}, etc., will have their
defaults replaced with the above types.

A note on \cppinline{weight_type}, it needs to provide the following method
calls,
\begin{cppcode*}{texcomments}
  w.ess();       // Get $\text{\normalfont\textsc{ess}} = 1/\sum_{i=1}^N(W^{(i)})^2$
  w.set_equal(); // Set $W^{(i)} = 1/N$
  w.resample_size(); // Get the size $N$.
  w.resample_data(); // Get a pointer to normalized weights
\end{cppcode*}
For the library's default class \cppinline{Weight}, the last two calls are the
same as \cppinline{w.size()} and \cppinline{w.data()}. However, this does not
need to be so. For example, below is the outline of an implementation of
\cppinline{weight_type} for distributed systems, assuming each computing node
has been allocated $N_r$ particles.
\begin{cppcode*}{texcomments}
  class WeightMPI
  {
    public:
    double ess()
    {
      double local = /* $\sum_{i=1}^{N_r}(W^{(i)})^2$ */;
      double global = /* Gather local from each all nodes */;
      // Broadcast the value of global

      return 1 / global;
    }

    std::size_t resample_size() { return /* $\sum N_r$ */; }

    double *resample_data()
    {
      if (rank == 0) {
        // Gather all normalized weights into a member data on this node
        // Say resample\_weight\_
        return resample_weight_.data();
      } else {
        return nullptr;
      }
    }

    void set_equal()
    {
      // Set all weights to $1 / \sum N_r$
      // Synchronization
    }
  };
\end{cppcode*}
When \cppinline{Particle<T>} performs resampling, it checks if the pointer
returned by \cppinline{w.resample_data()} is a null pointer. It will only
generate the vector $\{a_i\}_{i=1}^N$ (see section~\ref{ssub:State}) when this
it is a non-null pointer. And then pointer to it is passed a pointer to this
vector into \cppinline{T::copy}. Of course, the class \cppinline{T} also needs
to provide a suitable method \cppinline{copy} that can handle the distributed
system. By defining suitable \cppinline{WeightMPI} and \cppinline{T::copy}, the
library can be extended to handle distributed systems.

\subsection{Extending \protect\spt}
\label{sub:Extending SPT}

The \cppinline{SingleParticle<T>} can also be extended by the user. We have
already see in section~\ref{ssub:State} that if class \cppinline{T} is a
subclass of \cppinline{StateMatrix}, \cppinline{SingleParticle<T>} can has
additional methods to access the state. This class can be extended by defining
member class template inside class \cppinline{T}. For example, for the simple
particle filter in section~\ref{sub:A simple particle filter}, we can redefine
the \cppinline{PFState} as the following,
\cppfile{pf_state_sp.hpp}

The code looks slightly more complicated before, however, it has a few
benefits. First, we no longer need global constants such as \cppinline{PosX} to
track the index. We can access states more intuitively by calling
\cppinline{sp.pos_x()}, etc. This benefit will be much more noticeable for more
complex algorithm. Second, it allows more flexibility by allowing definition of
member method that operating on a single particle inside
\cppinline{single_particle_type}.

It is important to keep the object small and copying the object efficient. The
library will frequently pass argument of \cppinline{SingleParticle<T>} type by
value.
